---
layout: post
title: "python面向对象"
tag: python学习
---
- 面向过程：根据业务逻辑从上而下写代码
- 面向过程：对数据与函数绑定到一起，进行封装，这样可以快递进行开发



~~~python
1.定义类
class 类名：
	2.定义方法
class Dog :
	
    #可以直接添加属性，会在调用类的时候直接调用该方法
    def __init__(self):
        self.weight = 5
        self.color = "黄色"
    #另
    def __init__(self, newWeight, newColor):
        self.weight = newWeight
        self.color = newColor
	def bark(self):
    	print("汪汪汪")
    #方法可以对属性进行修改
    def eat(self):
        print("吃东西")
        self.weight += 5
 #创建一只小狗
xiaogou = Dog()
#调用小狗这个对象的一个方法
xiaogou.bark()
xiaogou.run()

#添加属性
xiaogou.weight = 5
xiaogou.color = "黄颜色"

xiaogou.eat()
print(xiaogou.weight)

#验证能否直接修改属性，让小狗的体重增加
xiaogou.weight += 5

wangcai = Dog()
print(wanngcai.weight)
print(wanngcai.weight)

wangcai = Dog(10,"黑色")


~~~

**理解self:**

- 表示自己
- 类中定义的叫方法，不在类中定义的叫函数，方法多的时候，按照self传给你的方法进行调用。
- self是python自动传进去
- self可以理解为就是你创建的对象，类似C++中的this
- 只要是类中的方法，都需要写上self



**__str__方法：**

- 替换了原来的默认的打印的是内存（魔法方法，一般有下换线的这种__***__）
- 一般用于print方法的时候

~~~python
def __str__(self):
    return "哈哈哈，我是小狗！"
~~~

> 尽量通过方法修改属性，最好不要直接修改属性



**存放家具例子：**

> item，self分别指的是谁，要能够分清楚

~~~python
#定义一个home家，类
class Home:

    def __init__(self, area):
        self.area = area
        self.rongNaList = []

    def __str__(self):
        mag = "家当前可用的面积为：" + str(self.area)
        return mag

    def containItem(self, item):
        #API接口，提供一个函数给你用，应用编程接口
        bedArea = item.getBedArea()
        #此方法也可以用，但是有危险
        #bedArea = item.area

        if self.area > bedArea:
            self.rongNaList.append(item)
            self.area -= bedArea
            print("当前添加"+ item.getBedName() + "成功。。。当前可用面积" + str(self.area))
        else:
            print("error:当前物品需要的面积大于家可用的面积:" + item.getBedName())

#定义一个 bed床 类
class Bed:

    def __init__(self, name, area):
        self.area = area
        self.name = name

    def __str__(self):
        msg = self.name + "床占用的面积为：" + str(self.area)
        return msg

    def getBedArea(self):
        return self.area

    def getBedName(self):
        return self.name

home = Home(100)
print(home)

bed = Bed('席梦思', 4)
print(bed)

home.containItem(bed)
#bed.getBedArea()
print(home)

bed2 = Bed("木板床", 10)
home.containItem(bed2)
print(home)

bed3 = Bed("超级大的床",170)
home.containItem(bed3)
print(home)
~~~



