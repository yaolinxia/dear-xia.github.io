---
layout: post
title: "python正则表达式"
tag: python学习
---

### re.compile 



### zip()函数

**zip()** 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。

~~~
zip([iterable, ...])
# iterabl -- 一个或多个迭代器;
~~~

### isinstance()

判断一个对象是否是一个已知的类型

~~~
isinstance(object, type)
~~~

~~~
>>> a = 5
>>> b = 'b'
>>> c = [1,2,3]
>>> d = {'d': 1}
>>> 
>>> isinstance(a, int)
True
>>> isinstance(a, list)
False
>>> isinstance(b, str)
True
>>> isinstance(b, int)
False
>>> isinstance(c, list)
True
>>> isinstance(d, dict)
True
~~~

### map,el表达式

```
list(map(lambda el: self.label_map_reverse[el], src))
```

**例子：**

~~~
from functools import reduce
 
l = ['a', 'bc', 'cde', 'defg']
lf = filter(lambda x: len(x) > 2, l)
 
lm = map(lambda x: x+'_n', l)
 
lr = reduce(lambda x,y: x+y, l)
 
print(list(lf))
 
print(list(lm))
 
print(lr)

~~~

**输出：**

~~~
['cde', 'defg']
['a_n', 'bc_n', 'cde_n', 'defg_n']
abccdedefg
~~~

### map 函数：

~~~
map(function, iterable, ...)
~~~

- function -- 函数
- iterable -- 一个或多个序列

~~~
>>>def square(x) :            # 计算平方数
...     return x ** 2
... 
>>> map(square, [1,2,3,4,5])   # 计算列表各个元素的平方
[1, 4, 9, 16, 25]
>>> map(lambda x: x ** 2, [1, 2, 3, 4, 5])  # 使用 lambda 匿名函数
[1, 4, 9, 16, 25]
 
# 提供了两个列表，对相同位置的列表数据进行相加
>>> map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])
[3, 7, 11, 15, 19]
~~~

### max()

~~~python 
#!/usr/bin/python
# -*- coding: UTF-8 -*-

import re

reg = re.compile('a*b*c*d*e*f*g*h*i*j*k*l*m*n*o*p*q*r*s*t*u*v*w*x*y*z*')
#返回一个字符串里按字母表排序的最长子字符串
def longest(s):
    print reg.findall(s)
#['abcde', 'ap', 'bcdef', '']
    return max(reg.findall(s), key=len)
#加或不加效果相同
print longest('abcdeapbcdef')
~~~

Python内置函数max()、min()和sorted()以及列表方法sort()都有一个参数**key用来指定排序规则**，解决的就是这个问题。

key参数应该是一个可调用对象，在Python中，类、自定义函数、内置函数、lambda表达式、带有特殊方法__call__()的对象都属于可调用函数。

![640?wx_fmt=png&wxfrom=5&wx_lazy=1](https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/xXrickrc6JTPmzyotOHb5YBQtnER2iccvZnibICv6uehJHs1Msyo0kSEdkOYH5tgAKw3tCVIXGYpleC3RpyP0MibyA/640?wx_fmt=png&wxfrom=5&wx_lazy=1)

