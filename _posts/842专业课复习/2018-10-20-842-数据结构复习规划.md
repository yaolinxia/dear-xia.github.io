---
layout: post
title: "842数据结构复习"
tag: 南大软院842复习
---

##  1. 算法分析

- 复杂性上界和平均复杂度的渐近分析；
- 最佳、最差和平均情况下的复杂度差异；
- 大O、Ω和 θ 符号 

### 1. 1 时间复杂度

#### 1.1.1 步骤

1）分析某个语句的执行次数（频度）
2）分析某个程序段执行的时间复杂度（用大O表示，要求写出推导过程）

#### 1.1.2 例子

- 例1

~~~java
for (int i = 1; i <= n;  i++)
    for (int j = 1; j<=n; j++)
         {   c[i][j] = 0.0;
               for ( int k = 1; k <= n; k++)
                    c[i][j] = c[i][j]+a[i][k]*b[k][j];
          }
次数为：n*n*n
~~~

- 例2

~~~java
x = 0; y = 0;
      for (int i = 1; i <= n; i++)
             for (int j = 1; j <= i; j++)
                    for (int k = 1; k <= j; k++)
                            x = x+y;
次数为：n*(n+1)*(n+2)/6                             
~~~

- 例3

~~~java
 int x = 91;  int y = 100;
         while(y>0)
        {   if(x>100) { x -= 10;  y--; }
             else x++;
        }
次数为： 1100次
~~~



### 1.2  空间负杂度



## 2. 数据类型

主要掌握基本概念，存储结构，基本操作（查找，插入，删除）, 可能结合时间复杂度来考，知道一些应用场景。

### 2.1 表

有由A1,A2,...,AN组成的表，表的大小为N，称Ai−1是Ai的前驱，Ai+1是Ai的后继。大小为0的表为空表。

表ADT上的操作常见的包括：插入、删除、索引、查找、清空、打印。这是些基本的操作，根据需要可以再添加。

- 逻辑&物理

![](https://ws1.sinaimg.cn/large/e93305edgy1fwewyucnurj20e705aaa6.jpg)

- 数组实现

  数组实现的表，索引为O(1)，插入和删除的最坏情况为O(N)，查找、清空和打印为O(N)。

- 链表实现

  链表由一系列在内存中可以不相连的结构组成，每个结构含有表元素和指向后继结构的指针，最后一个结构的指针为NULL。

  ![img](https://upload-images.jianshu.io/upload_images/7647943-2e533966d3d378e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/746/format/webp)

  **创建头节点**

  手动new一个新的Node，将Node的next置为NULL即可。

  head = new Node(0);head->next = NULL;



  ![img](https:////upload-images.jianshu.io/upload_images/7647943-cbc66f1595b781c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/315/format/webp)





  ![img](https:////upload-images.jianshu.io/upload_images/7647943-1903c5f7ad6fe638.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/392/format/webp)





  ![img](https:////upload-images.jianshu.io/upload_images/7647943-1583afc7d4da64db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/227/format/webp)



  **从头插入一个新的节点**

  手动new出一个新的节点p，使p的next的指向head->next所指向的地址,然后将head->next从新指向p即可。

  Node * p = new Node(int);  p->next = head->next;   head->next = p;



  ![img](https:////upload-images.jianshu.io/upload_images/7647943-55e5ab11292f954f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/663/format/webp)





  ![img](https:////upload-images.jianshu.io/upload_images/7647943-35363848047a29ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/251/format/webp)



  **删除指定节点**

  先遍历到指定节点的前一个节点,然后通过将前一个节点的next指针指向指定节点的下一个节点,达到悬空指定节点的效果,然后删除指定节点即可。



  ![img](https:////upload-images.jianshu.io/upload_images/7647943-24f2e22ea3bfc473.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/633/format/webp)





  ![img](https:////upload-images.jianshu.io/upload_images/7647943-cda6f913bcdd8adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/405/format/webp)



  **修改指定节点**

  遍历到指定节点的位置,将其data修改为要修改的值即可。



  ![img](https:////upload-images.jianshu.io/upload_images/7647943-cc24becb42fd9092.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/590/format/webp)





  ![img](https:////upload-images.jianshu.io/upload_images/7647943-d7094717c6220904.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/377/format/webp)



  **链表反转**

  方法1：使用3个指针遍历单链表，逐个链接点进行反转。

  	定义三个临时节点指向头结点之后的第1个节点p，第2个节点q和第3个节点m。将p->next置为空,然后将q->next = p,然后将p向后移动一个节点,即p = q,最后将q向后移动一个节点,即q = m,最后把m向后移动一个节点,即m = m->next;依此类推直到m等于NULL,然后将q->next = p,最后将head->next指向q(即目前第一个节点疑,也就是原本最后的一个节点)。

   	通过三个节点达到从头开始逐个逆序的目的。



  ![img](https:////upload-images.jianshu.io/upload_images/7647943-22c947b6fc6f5f85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/477/format/webp)



  方法2：从第2个节点到第N个节点，依次逐节点插入到第1个节点(head节点)之后，最后将第一个节点挪到新表的表尾。



  ![img](https:////upload-images.jianshu.io/upload_images/7647943-0402ddef2664cb7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/448/format/webp)



  从图上观察，方法是：对于一条链表，从第2个节点到第N个节点，依次逐节点插入到第1个节点(head节点)之后，(N-1)次这样的操作结束之后将第1个节点挪到新表的表尾即可。

  代码如下:



  ![img](https:////upload-images.jianshu.io/upload_images/7647943-5c9d912a5e5126a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/389/format/webp)


- 应用

  - 逆转链表

    ~~~java
    public  void  inverse( ListNode f )
     {  if ( f = = NULL ) return;
         ListNode  p = f . link ;  pr = NULL; 
         while ( p ! = NULL )
        {   f . link = pr ;
             pr = f ;
             f = p ;
             p = p . link ;
        }
         f . link = pr ;
      }
    ~~~

  - 多项式相加

    参考网址：

    https://blog.csdn.net/bingjianIT/article/details/60779641

    <http://data.biancheng.net/view/90.html>

    <https://blog.csdn.net/u014492609/article/details/39453481>

  - 约瑟夫问题

    ![](https://ws1.sinaimg.cn/large/e93305edgy1fwez57vwjbj20is04a74k.jpg)

    参考网址：

    <http://maskray.me/blog/2013-08-27-josephus-problem-two-log-n-solutions>

    <https://www.nowcoder.com/questionTerminal/11b018d042444d4d9ca4914c7b84a968>

    <https://blog.csdn.net/zhang5476499/article/details/52432870>

  - 双链表的插入，删除

    参考网址：

    <https://blog.csdn.net/lisayh/article/details/79216796>

    <https://juejin.im/post/5b5d1a9af265da0f47352f14>

    <https://segmentfault.com/a/1190000002519828>

  - 特殊矩阵的压缩存储 （南大PPT讲解很详细）

    **数列掌握等差数列！**

    ![](https://ws1.sinaimg.cn/large/e93305edgy1fweyrlvynhj207f05kmxt.jpg)

    ![](https://ws1.sinaimg.cn/large/e93305edgy1fwey3to7xyj20j10br74r.jpg)

    ![1540037383950](C:\Users\yao\AppData\Roaming\Typora\typora-user-images\1540037383950.png)

    ![](https://ws1.sinaimg.cn/large/e93305edgy1fwey62nmowj20i10ctwev.jpg)

    ![1540037537238](C:\Users\yao\AppData\Roaming\Typora\typora-user-images\1540037537238.png)

    ![](https://ws1.sinaimg.cn/large/e93305edgy1fwey9r58a3j20g804f749.jpg)

    ![](https://ws1.sinaimg.cn/large/e93305edgy1fweybcrwdkj20ig0d70t4.jpg)

    ![](https://ws1.sinaimg.cn/large/e93305edgy1fweyid2d41j20hs0a0gls.jpg)

    ![](https://ws1.sinaimg.cn/large/e93305edgy1fweyme9piyj20is0d13yw.jpg)

    ![](https://ws1.sinaimg.cn/large/e93305edgy1fweynn1tnwj20gt0aet8w.jpg)

    ![](https://ws1.sinaimg.cn/large/e93305edgy1fweyq6a92wj20ht0a5glt.jpg)

    ![](https://ws1.sinaimg.cn/large/e93305edgy1fweyu3ehejj20h2071glp.jpg)



    ![](https://ws1.sinaimg.cn/large/e93305edgy1fweyza4hilj20hm0cy3yt.jpg)

- 参考网址

  <https://www.jianshu.com/p/ad56483a7cdb>



### 2.2 字符串

### 2.3 栈

- 应用

  - 对表达式求值。

    中缀----后缀----对后缀表达式求值

  - 递归函数的实现。

  - PPT：第4章中用非递归实现中序,后序遍历

### 2.4 队列

- 应用

  - 已知队尾元素的位置与元素的个数，求队头元素的位置。

    ![](https://ws1.sinaimg.cn/large/e93305edgy1fwexx787zoj20ep089glo.jpg)


### 2.5 树

#### 2.5.1 二叉树

- 二叉树的定义
- 二叉树的存储
- 二叉树的遍历

- 线索二叉树
- 二叉排序树
- 平衡二叉树

#### 2.5.2 森林

- 森林与二叉树的转换
- 森林的遍历

#### 2.5.3 树的应用

- 等价类问题
- 哈夫曼树
- 哈夫曼编码

### 2.6 图

#### 2.6.1 图的概念

#### 2.6.2 图的存储

#### 2.6.3 图的遍历

#### 2.6.4 图的基本应用

- 最小生成树
- 最短路径
- 拓扑排序
- 关键路径


## 3. 基本算法

### 3.1 查找

### 3.2 排序 

#### 3.2.1 插入排序

#### 3.2.2 冒泡排序

#### 3.2.3 简单选择排序

#### 3.3.4 希尔排序

#### 3.3.5 快速排序

#### 3.3.6 堆排序

#### 3.3.7 二路归并排序

#### 3.3.8 基数排序

#### 3.3.9 各算法排序比较



## 4. 算法策略

### 4.1 穷举

### 4.2 贪婪

### 4.3 分治

### 4.4 回溯





## 5. 递归算法









