---
layout: post
title: "842软工复习2"
tag: 南大软院842复习
---

### 第十四章 详细设计中的面向对象方法下的模块化

- **降低访问耦合**

  ### **迪米特法则**

  > 参考网址<https://blog.csdn.net/zhengzhb/article/details/7296930>

  **定义：**一个对象应该对其他对象保持最少的了解。

  **问题由来：**类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。

  **解决方案：**尽量降低类与类之间的耦合。

  ~~~
  1. 迪米特法则又叫最少知道原则，通俗的来讲，就是一个类对自己依赖的类知道的越少越好。
  2. 对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。
  3. 迪米特法则还有一个更简单的定义：只与直接的朋友通信。
  4. 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。
  5. 耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为
  直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。
  ~~~

  **例子1：**

  有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。

  ~~~java
  //总公司员工
  class Employee{
  	private String id;
  	public void setId(String id){
  		this.id = id;
  	}
  	public String getId(){
  		return id;
  	}
  }
   
  //分公司员工
  class SubEmployee{
  	private String id;
  	public void setId(String id){
  		this.id = id;
  	}
  	public String getId(){
  		return id;
  	}
  }
   
  class SubCompanyManager{
  	public List<SubEmployee> getAllEmployee(){
  		List<SubEmployee> list = new ArrayList<SubEmployee>();
  		for(int i=0; i<100; i++){
  			SubEmployee emp = new SubEmployee();
  			//为分公司人员按顺序分配一个ID
  			emp.setId("分公司"+i);
  			list.add(emp);
  		}
  		return list;
  	}
  }
   
  class CompanyManager{
   
  	public List<Employee> getAllEmployee(){
  		List<Employee> list = new ArrayList<Employee>();
  		for(int i=0; i<30; i++){
  			Employee emp = new Employee();
  			//为总公司人员按顺序分配一个ID
  			emp.setId("总公司"+i);
  			list.add(emp);
  		}
  		return list;
  	}
  	
  	public void printAllEmployee(SubCompanyManager sub){
  		List<SubEmployee> list1 = sub.getAllEmployee();
  		for(SubEmployee e:list1){
  			System.out.println(e.getId());
  		}
   
  		List<Employee> list2 = this.getAllEmployee();
  		for(Employee e:list2){
  			System.out.println(e.getId());
  		}
  	}
  }
   
  public class Client{
  	public static void main(String[] args){
  		CompanyManager e = new CompanyManager();
  		e.printAllEmployee(new SubCompanyManager());
  	}
  }
  ~~~

  **问题所在：**

  现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:

  **修改后**

  ~~~jav
  class SubCompanyManager{
  	public List<SubEmployee> getAllEmployee(){
  		List<SubEmployee> list = new ArrayList<SubEmployee>();
  		for(int i=0; i<100; i++){
  			SubEmployee emp = new SubEmployee();
  			//为分公司人员按顺序分配一个ID
  			emp.setId("分公司"+i);
  			list.add(emp);
  		}
  		return list;
  	}
  	public void printEmployee(){
  		List<SubEmployee> list = this.getAllEmployee();
  		for(SubEmployee e:list){
  			System.out.println(e.getId());
  		}
  	}
  }
   
  class CompanyManager{
  	public List<Employee> getAllEmployee(){
  		List<Employee> list = new ArrayList<Employee>();
  		for(int i=0; i<30; i++){
  			Employee emp = new Employee();
  			//为总公司人员按顺序分配一个ID
  			emp.setId("总公司"+i);
  			list.add(emp);
  		}
  		return list;
  	}
  	
  	public void printAllEmployee(SubCompanyManager sub){
  		sub.printEmployee();
  		List<Employee> list2 = this.getAllEmployee();
  		for(Employee e:list2){
  			System.out.println(e.getId());
  		}
  	}
  }
  ~~~

  修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。        迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。

**例子2：**

> 参考网址：<https://tianweili.github.io/2015/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/>

​	现在市面上各种人脉书上很多都会提到“六度人脉”这个理论，这个理论说的是你与世界上任何一个人中间只隔了六个人。也就是说你想找任何一个人，无论这个人是政界要人，还是商界巨鳄，抑或是明星名人，你最多只通过六个人就可以联系到他（想想还有点小激动呢-_-#）。

​	我们暂且不论这个理论是对是错，在现实生活中我们也经常遇到这样的情况。比如你想办一件事情，但是凭借你的能力是做不到的，而你周围的朋友也无法帮你办到。但是恰好你有一个朋友认识有另外一个朋友可以办得成此事，那么你只有拜托你这位朋友中间牵线搭桥，让他的朋友帮你办好此事。

在这个例子中，我们就暂且定义你为A，你的朋友为B，你朋友的朋友为C好了。

## 反面教材

实现代码如下：

1.类A和类B是好朋友，能找到类B来帮忙：

```
public class A {

	public String name;

	public A(String name) {
		this.name = name;
	}

	public B getB(String name) {
		return new B(name);
	}

	public void work() {
		B b = getB("李四");
		C c = b.getC("王五");
		c.work();
	}
}
```

2.类B和类C是好朋友，能知道类C来帮忙：

```
public class B {

	private String name;

	public B(String name) {
		this.name = name;
	}

	public C getC(String name) {
		return new C(name);
	}
}
```

3.类C能够办成此事：

```
public class C {

	public String name;

	public C(String name) {
		this.name = name;
	}

	public void work() {
		System.out.println(name + "把这件事做好了");
	}
}
```

4.场景类

```
public class Client {
	public static void main(String[] args) {
		A a = new A("张三");
		a.work();
	}
}
```

运行结果如下：

```
王五把这件事做好了
```

上面的输出虽然是把事情成功办好了，但是仔细看业务逻辑明显是不对的。A和C又不是好朋友，为什么在类A中会出现类C呢？他们又互相不认识。

看到这里很多人都会明白，这种场景在实际开发中是非常常见的一种情况。对象A需要调用对象B的方法，对象B有需要调用对象C的方法……就是常见的getXXX().getXXX().getXXX()……类似于这种代码。如果你发现你的代码中也有这样的代码，那就考虑下是不是违反迪米特法则，是不是要重构一下了。

## 正确例子

为了符合迪米特法则，也为了让业务逻辑能够说得通，我们把上面的例子稍微修改一下。

代码如下：

1.类A和类B是好朋友，能找到类B来帮忙：

```
public class A {

	public String name;

	public A(String name) {
		this.name = name;
	}

	public B getB(String name) {
		return new B(name);
	}

	public void work() {
		B b = getB("李四");
		b.work();
	}
}
```

2.类B和类C是好朋友，能知道类C来帮忙：

```
public class B {

	private String name;

	public B(String name) {
		this.name = name;
	}

	public C getC(String name) {
		return new C(name);
	}
	
	public void work(){
		C c = getC("王五");
		c.work();
	}
}
```

3.类C能够办成此事：

```
public class C {

	public String name;

	public C(String name) {
		this.name = name;
	}

	public void work() {
		System.out.println(name + "把这件事做好了");
	}
}
```

4.场景类

```
public class Client {
	public static void main(String[] args) {
		A a = new A("张三");
		a.work();
	}
}
```

运行结果如下：

```
王五把这件事做好了
```

上面代码只是修改了下类A和B的work方法，使之符合了迪米特法则：

- 类A只与最直接的朋友类B通信，不与类C通信；
- 类A只调用类B提供的方法即可，不用关心类B内部是如何实现的（至于B是怎么调用的C，这些A都不用关心）。

## 总结

迪米特法则的目的是让类之间解耦，降低耦合度。只有这样，类的可复用性才能提高。

但是迪米特法则也有弊端，它会产生大量的中转类或跳转类，导致系统的复杂度提高。

所以我们不要太死板的遵守这个迪米特法则，在系统设计的时候，在弱耦合和结构清晰之间反复权衡。尽量保证系统结构清晰，又能做到低耦合。

**例子3：**

> 这篇博客讲的很详细了，例子有点难
>
> 参考网址：<https://www.jianshu.com/p/30931aab5ea0>

前面我们谈到了几种类与类之间的关系,现在我们来深入一下对象与对象之间的通信问题.
 为什么要深入对象与对象之间的通信呢,其根本在于,系统中不会存在唯一的对象,不同的对象势必要相互进行交流.

------

# 初学者的问题

在我们刚开始学习编程的时候，通常会将所有的方法都声明为公有（public），但随着我们代码量的增加，我们都会遇到一个典型的问题：

> 在调用某个对象的方法时，我们发现编译器提示这个对象所有的方法，这意味着该对象处在不安全的状态。为什么这么说呢？如果我们将这个对象比作一个人，那么这个人在别人面前是赤裸的，没有任何隐私，这让别人有机会观察你的一切行为，并某刻致命一击。除此之外，这个完全暴露的人，也会让别人不知所措。

这显然不是我们想要的，因此我们需要某种机制来限制的对象信息的公开：哪些信息是可以公开的，哪些是不可以公开的，在java中，我们通过方法的权限来实现这一点，比如private修饰的方法只有对象自己内部可以调用，public修饰的方法是公开给其他对象的等。

现在，你可能已经明白，java的设计者为什么要“多此一举”的为方法设计权限了。那么有人会问，我该怎么确定哪个方法应该被设计成公有的，哪些又应该被设计成私有的呢？

当你心里有这个疑问的时候，说明你已经开始关注我们经常提到的面向对象编程的原则之一：封装，即如何划分对象的结构。
 我们都知道对象的结构的可被划分为静态属性和动态属性，所谓的静态属性就是值对象固有的属性，比如任何一个生命体都有年龄，而动态属性也称为行为属性，指的是对象所表现出来的行为，比如袋鼠能跳，能呼吸等。而这静态属性和动态属性又可以细分为可公开的静态属性，可公开的动态属性等。也就是说，划分对象的结构实则就是确定某个对象的动态属性和静态属性，在此基础上再来确定属性是否可公开等。

不难发现，这个过程和我们的认知的思维过程很类似：大脑试图从各种各样的的物体中抽取特征。比如，我们看到猫，狗，仙人掌，为了能区分它们，我们的大脑会对这三者进行特征抽取，比如猫和狗都可以移动，有眼睛，会叫，有爪子，而仙人掌则是不可移动，有刺，不能叫等，通过这种特种抽取，我们能区分出动物和植物的区别。换言之，我们之所以能区分出不同的物体，都是因为我们的大脑已经默默的为我们做了特征抽取的工作，这个过程如果由我们主动去做就称之为抽象编程。

------

# 揭秘迪米特法则

迪米特法则（Law of demeter,缩写是LOD）要求：一个对象应该对其他对象保持最少了解， 通缩的讲就是一个类对自己依赖的类知道的越少越好，也就是对于被依赖的类，向外公开的方法应该尽可能的少。

迪米特法则还有一种解释：**Only talk to your immediate friends**，即只与直接朋友通信.首先来解释编程中的朋友:两个对象之间的耦合关系称之为朋友,通常有依赖,关联,聚合和组成等.而直接朋友则通常表现为关联,聚合和组成关系,即两个对象之间联系更为紧密,通常以成员变量,方法的参数和返回值的形式出现.

那么为什么说是要与直接朋友通信呢?观察直接朋友出现的地方,我们发现在直接朋友出现的地方,大部分情况下可以接口或者父类来代替,可以增加灵活性.
 (需要注意,在考虑这个问题的时候,我们只考虑新增的类,而忽视java为我们提供的基础类.)

## 实例演示

不难发现,迪米特法则强调了一下两点：

- 第一要义:从被依赖者的角度来说：只暴露应该暴露的方法或者属性，即在编写相关的类的时候确定方法/属性的权限
- 第二要义:从依赖者的角度来说，只依赖应该依赖的对象

先来解释第一点，我们使用计算机来说明,以关闭计算机为例:

> 当我们按下计算机的关机按钮的时候，计算机会执行一些列的动作会被执行：比如保存当前未完成的任务，然后是关闭相关的服务，接着是关闭显示器，最后是关闭电源，这一系列的操作以此完成后，计算机才会正式被关闭。

现在,我们来用简单的代码表示这个过程，在不考虑迪米特法则情况下，我们可能写出以下代码

```
//计算机类
public class Computer{

    public void saveCurrentTask(){
        //do something
    }
    public void closeService(){
        //do something
    }
    public void closeScreen(){
        //do something
    }
    
    public void closePower(){
        //do something
    }
    
    public void close(){
        saveCurrentTask();
        closeService();
        closeScreen();
        closePower();
    }
}

//人
public class Person{
    private Computer c;
    
    ...
    
    public void clickCloseButton(){
      //现在你要开始关闭计算机了，正常来说你只需要调用close（）方法即可，
      //但是你发现Computer所有的方法都是公开的，该怎么关闭呢？于是你写下了以下关闭的流程：        
        c.saveCurrentTask();
        c.closePower();
        c.close();
        
        //亦或是以下的操作        
        c.closePower();
        
        //还可能是以下的操作
        c.close();
        c.closePower();
    }

}
```

发现上面的代码中的问题了没?
 我们观察clickCloseButton()方法,我们发现这个方法无法编写:c是一个完全暴露的对象，其方法是完全公开的，那么对于Person来说，当他想要执行关闭的时候，却发现不知道该怎么操作:该调用什么方法?靠运气猜么?如果Person的对象是个不按常理出牌的,那这个Computer的对象岂不是要被搞坏么?

## 迪米特法则第一要义

现在我们来看看迪米特法则的第一点：从被依赖者的角度，只应该暴露应该暴露的方法。那么这里的c对象应该哪些方法应该是被暴露的呢？很显然，对于Person来说，只需要关注计算机的关闭操作，而不关心计算机会如何处理这个关闭操作，因此只需要暴露`close（）`方法即可。
 那么上述的代码应该被修改为：

```
//计算机类
public class Computer{

    private void saveCurrentTask(){
        //do something
    }
    private void closeService(){
        //do something
    }
    private void closeScreen(){
        //do something
    }
    
    private void closePower(){
        //do something
    }
    
    public void close(){
        saveCurrentTask();
        closeService();
        closeScreen();
        closePower();
    }
}

//人
public class Person{
    private Computer c;
    ...

    public  void clickCloseButton(){
       c.close();
    }

}
```

看一下它的类图:



![img](https:////upload-images.jianshu.io/upload_images/142377-b572dc6ef3aa455f?imageMogr2/auto-orient/strip%7CimageView2/2/w/534/format/webp)

这里写图片描述

接下来，我们继续来看迪米特法则的第二层含义:从依赖者的角度来说，只依赖应该依赖的对象。
 这句话令人有点困惑，什么叫做应该依赖的对象呢？我们还是用上面“关闭计算机”的例子来说明：
 准确的说，计算机包括操作系统和相关硬件，我们可以将其划分为System对象和Container对象。当我们关闭计算机的时候，本质上是向操作系统发出了关机指令，而实则我们只是按了一下关机按钮，也就是我们并没有依赖System的对象，而是依赖了Container。这里Container就是我们上面所说的直接朋友---只和直接朋友通信.

我们就这点,继续深入讨论一下:
 `only talk to your immedate friends`
 这句话只说明了要和直接朋友通信,但是我觉得这还不完整,我更愿意将其补充为:
 make sure your friends,only talk to your immedate friends,don't speak to strangers.
 大意是:**确定你真正的朋友,并只和他们通信,并且不要和陌生人讲话.**这样做有个很大的好处就是,能够简化对象与对象之间的通信,进而减轻依赖,提供更高的灵活性,当然也可以提供一定的安全性.

> 现在来想想现实世界中的这么一种情况:你是一个令人瞩目的公众人物,周围的每个人都知道你的名字,当你独自走在大街上的时候会是怎么样的一种场景?每个人都想要和你聊天!,和你交换信息!!接着,你发现自己已经寸步难行了.如果这时候你有一个经纪人,来帮你应对周围的人,而你就只和这个经纪人通信,这样就大大减轻了你的压力,不是么?此时,这个经济人就相当于你的直接朋友.

------

## 迪米特法则第二要义

现在,我们再回顾"关机计算机"这个操作,前面的代码只是遵从了"暴漏应该暴漏的方法"这一点,现在我们结合第二点来进行改进:System和Container相比,System并非Person的直接朋友,而Container才是(Person直接打交道的是Container).因此我们需要将原有的Computer拆分成System和Cotainer,然后使Person只与Container通信,因此代码修改为:

```
//操作系统
public class System{

    private void saveCurrentTask(){
        //do something
    }
    private void closeService(){
        //do something
    }
    private void closeScreen(){
        //do something
    }
    
    private void closePower(){
        //do something
    }
    
    public void close(){
        saveCurrentTask();
        closeService();
        closeScreen();
        closePower();
    }
}

//硬件设备容器
public class Container{
    private System mSystem;
    
    public void sendCloseCommand(){
        mSystem.close();
    }
}

//人
ublic class Person{
    private Container c;
    ....
    
    public void clickCloseButton(){
       c.sendCloseCommand();
    }

}
```

来看一下它的类图:



![img](https:////upload-images.jianshu.io/upload_images/142377-f7a16a9ef398d4e5?imageMogr2/auto-orient/strip%7CimageView2/2/w/679/format/webp)

这里写图片描述

------

## 重构,改善既有设计

在上文中,我们还提到,直接朋友出现的地方,我们可以采用其接口或者父类来代替.那么在这里,我们就可以为Container和System提供相应的接口

```
//System interface
public interface ISystem{
    void close();
}

//System
public class System implements ISystem{
    
    private void saveCurrentTask(){
        //do something
    }
    
    private void closeService(){
        //do something
    }
    
    private void closeScreen(){
        //do something
    }
    
    private void closePower(){
        //do something
    }
    
    @override
    public void close(){
        saveCurrentTask();
        closeService();
        closeScreen();
        closePower();
    }
}

//IContainer interface
public interface IContainer{
    void sendCloseCommand();
}

//Contanier
public class Container implements IContainer{
    private System mSystem;
    
    @override
    public void sendCloseCommand(){
        mSystem.close();
    }
}

//Person
ublic class Person{
    private IContainer c;
    ....
    
    public void clickCloseButton(){
       c.sendCloseCommand();
    }

}
```

来看一下它的类图:



![img](https:////upload-images.jianshu.io/upload_images/142377-f8eede9a056736af?imageMogr2/auto-orient/strip%7CimageView2/2/w/729/format/webp)

这里写图片描述

对比这两种方案,明显这种方案二的解耦程度更高,灵活大大增强.不难发现,这应用了我们前面提到的依赖倒置,即**面向接口编程**.

除此之外,我们发现随着不断的改进,类的数量也在不断的增加,从2个增加到5个,这意味着为了解耦和提高灵活性通常要编写的类的数量会翻倍.因此,你需要在这做一个权衡,切莫刻意为了追求设计,而导致整个系统非常的冗余,最终可能得不偿失.

------

# 总结

有人会觉得Container像是一个中介(代理).没错,我们确实可以称其为中介,但这并不能否认他是我们的直接朋友:在很多情况下,中介可以说是我们的一种代表,因此将其定义为直接朋友是没有任何问题的.比如,当你想要租房的时候,你可以找房屋中介,对方会按照你的标准为你寻找合适的住房.但是问题来了:那么做一件事情需要多少中介呢?总不能是我委托一个中介A帮我找房子,但中介A又委托了中介B,中介B又委托了中介C....等等,如果真的是这样,那还不如我自己去找房子效率更高.在实际开发中,委托的层次要控制在6层以下,多余6层以上的会使得系统过分的冗余和并切会委托层次过多而导致开发人员无法正确的理解流程,产生风险的可能会大大提高.

到目前,我们已经彻底的了解了迪米特法则.

作者：涅槃1992

链接：https://www.jianshu.com/p/30931aab5ea0

來源：简书

- **其他参考网址：**

  <https://www.zybuluo.com/XingdingCAO/note/913912>

  <https://www.ithome.com.tw/voice/98670>





